/* 

This program:

* takes 2 directorys (relaitve or absolute) as input
* takes each file (including hidden) in first directory supplied on commandline and finds ALL files recursively in second directory with same name
* if match(es) are found, shas are produced and compared with file content
* differences are reported
* diff command to take next step is genrated
* stats showing amount of files reviewed and compared are shown at end

This program was generated by ChatGPT (non-agentic mode) using GPT-5 (regular). Most attempts to reach this point was around formatting and considering which files to diff (e.g. hidden? or only ones in first directory, etc.).

$ tree -a dir1
dir1
├── .helmignore                  # contents: "/tmp\n"
├── deploy.yaml                  # contents: "kind: Deployment\n"
├── scripts
│   └── generateTestOverride.sh  # contents: "echo hello\n"
└── values.yaml                  # contents: "replicas: 1\n"

$ tree -a dir2
dir2
├── .helmignore                  # contents: "/tmp\n"                   (same as dir1)
├── charts1
│   └── values.yaml              # contents: "replicas: 2\n"           (DIFFERENT)
├── charts2
│   └── values.yaml              # contents: "replicas: 1\n"           (SAME)
├── k8s
│   └── deploy.yaml              # contents: "kind: Deployment\n"      (SAME)
└── scripts
    └── extra.sh                 # contents: "echo extra\n"            (ignored: name not in dir1)

$ go run dir-diff-by-file-name.go ./dir1 ./dir2/

# values.yaml — two matches in dir2: one different, one same
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa dir1/values.yaml
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb dir2/charts1/values.yaml
diff -y 'dir1/values.yaml' 'dir2/charts1/values.yaml'
---
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa dir1/values.yaml
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa dir2/charts2/values.yaml
diff -y 'dir1/values.yaml' 'dir2/charts2/values.yaml'
---

# deploy.yaml — identical across dirs
cccccccccccccccccccccccccccccccccccccccc dir1/deploy.yaml
cccccccccccccccccccccccccccccccccccccccc dir2/k8s/deploy.yaml
diff -y 'dir1/deploy.yaml' 'dir2/k8s/deploy.yaml'
---

# .helmignore — identical and INCLUDED (hidden file)
dddddddddddddddddddddddddddddddddddddddd dir1/.helmignore
dddddddddddddddddddddddddddddddddddddddd dir2/.helmignore
diff -y 'dir1/.helmignore' 'dir2/.helmignore'
---

# generateTestOverride.sh — no counterpart in dir2
eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee dir1/scripts/generateTestOverride.sh
<empty>
<empty>
---

files in one: 4
files in two: 5
number of deltas: 1
number of total comparisons done: 5

*/


package main

import (
	"crypto/sha1"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	algo := flag.String("algo", "sha1", "hash algorithm: sha1 or sha256")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] <dir1> <dir2>\n\n", filepath.Base(os.Args[0]))
		fmt.Fprintln(os.Stderr, "Shows all files from dir1 (including hidden). Compares by NAME only against dir2.")
		fmt.Fprintln(os.Stderr, "For each file in dir1:")
		fmt.Fprintln(os.Stderr, "  - If dir2 has one or more same-name files: print one block per comparison (even if equal).")
		fmt.Fprintln(os.Stderr, "  - If dir2 has none: print placeholders for the second line and diff command.")
		fmt.Fprintln(os.Stderr, "Block format:")
		fmt.Fprintln(os.Stderr, "  <sha> <dir1/path>")
		fmt.Fprintln(os.Stderr, "  <sha|<empty>> <dir2/path|<empty>>")
		fmt.Fprintln(os.Stderr, "  diff -y '<dir1/path>' '<dir2/path>' | <empty>")
		fmt.Fprintln(os.Stderr, "  ---")
		fmt.Fprintln(os.Stderr, "\nOptions:")
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() != 2 {
		flag.Usage()
		os.Exit(2)
	}
	dir1, dir2 := flag.Arg(0), flag.Arg(1)

	if err := mustDir(dir1); err != nil { fatal(err) }
	if err := mustDir(dir2); err != nil { fatal(err) }

	// filename -> []paths (includes hidden; follows symlinks to files) + total counts
	nameToPaths1, filesInOne, err := buildAllByName(dir1)
	if err != nil { fatal(fmt.Errorf("walking %s: %w", dir1, err)) }
	nameToPaths2, filesInTwo, err := buildAllByName(dir2)
	if err != nil { fatal(fmt.Errorf("walking %s: %w", dir2, err)) }

	// Deterministic over filenames from dir1
	var names []string
	for n := range nameToPaths1 { names = append(names, n) }
	sort.Strings(names)

	hashCache := make(map[string]string)

	var totalComparisons int64 // matched pairs + unmatched (count unmatched as 1)
	var deltas int64           // only pairs with differing hashes

	for _, name := range names {
		refPaths := nameToPaths1[name]      // all dir1 paths with this filename (duplicates allowed)
		candPaths, ok := nameToPaths2[name] // all dir2 paths with this filename

		if !ok || len(candPaths) == 0 {
			// No counterpart(s) in dir2: print one block per ref with placeholders
			for _, ref := range refPaths {
				refHash, err := getHash(ref, *algo, hashCache)
				if err != nil {
					fmt.Fprintf(os.Stderr, "error hashing %s: %v\n", ref, err)
					continue
				}
				totalComparisons++
				fmt.Printf("%s %s\n", refHash, ref)
				fmt.Println("<empty>")
				fmt.Println("<empty>")
				fmt.Println("---")
			}
			continue
		}

		// Compare every ref path against every candidate path (print all, even if equal)
		for _, ref := range refPaths {
			refHash, err := getHash(ref, *algo, hashCache)
			if err != nil {
				fmt.Fprintf(os.Stderr, "error hashing %s: %v\n", ref, err)
				continue
			}
			for _, cand := range candPaths {
				candHash, err := getHash(cand, *algo, hashCache)
				if err != nil {
					fmt.Fprintf(os.Stderr, "error hashing %s: %v\n", cand, err)
					continue
				}
				totalComparisons++
				if refHash != candHash {
					deltas++
				}
				fmt.Printf("%s %s\n", refHash, ref)
				fmt.Printf("%s %s\n", candHash, cand)
				fmt.Printf("diff -y %s %s\n", shellQuote(ref), shellQuote(cand))
				fmt.Println("---")
			}
		}
	}

	// Stats
	fmt.Printf("files in one: %d\n", filesInOne)
	fmt.Printf("files in two: %d\n", filesInTwo)
	fmt.Printf("number of deltas: %d\n", deltas)
	fmt.Printf("number of total comparisons done: %d\n", totalComparisons)
}

func mustDir(p string) error {
	fi, err := os.Stat(p)
	if err != nil { return err }
	if !fi.IsDir() { return fmt.Errorf("%s is not a directory", p) }
	return nil
}

// buildAllByName walks root and returns filename -> sorted []paths and total count.
// Includes dotfiles and follows symlinks to files (but not symlinked directories).
func buildAllByName(root string) (map[string][]string, int, error) {
	out := make(map[string][]string)
	count := 0
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil { return err }

		// If it's a symlink to a directory, don't descend (WalkDir won't anyway).
		if d.IsDir() {
			return nil
		}

		// Follow symlinks to files by using os.Stat (target attributes).
		info, err := os.Stat(path)
		if err != nil {
			// Broken symlink or permission issue: skip
			return nil
		}
		if !info.Mode().IsRegular() {
			return nil
		}

		count++
		name := filepath.Base(path) // includes names like ".helmignore"
		out[name] = append(out[name], path)
		return nil
	})
	if err != nil { return nil, 0, err }
	for k := range out { sort.Strings(out[k]) }
	return out, count, nil
}

func getHash(path, algo string, cache map[string]string) (string, error) {
	if h, ok := cache[path]; ok { return h, nil }
	f, err := os.Open(path)
	if err != nil { return "", err }
	defer f.Close()

	var sum string
	switch strings.ToLower(algo) {
	case "sha1":
		h := sha1.New()
		if _, err := io.Copy(h, f); err != nil { return "", err }
		sum = hex.EncodeToString(h.Sum(nil))
	case "sha256":
		h := sha256.New()
		if _, err := io.Copy(h, f); err != nil { return "", err }
		sum = hex.EncodeToString(h.Sum(nil))
	default:
		return "", fmt.Errorf("unsupported algo %q (use sha1 or sha256)", algo)
	}
	cache[path] = sum
	return sum, nil
}

// shellQuote returns a POSIX-safe single-quoted string for shell commands.
func shellQuote(s string) string {
	if s == "" { return "''" }
	var b strings.Builder
	b.WriteByte('\'')
	for _, r := range s {
		if r == '\'' { b.WriteString("'\\''") } else { b.WriteRune(r) }
	}
	b.WriteByte('\'')
	return b.String()
}

func fatal(err error) {
	fmt.Fprintf(os.Stderr, "error: %v\n", err)
	os.Exit(2)
}
